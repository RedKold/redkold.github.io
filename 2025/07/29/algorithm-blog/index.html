<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法成长日记 | RedKold的小站</title><meta name="author" content="RedKold"><meta name="copyright" content="RedKold"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前面的话 到大三了才深刻意识到自己算法基础的薄弱，趁暑期有时间应该多做一些算法题。 写一个c++小算法还不如大一的自己了。所以在这里分享一些。   更新了分类栏目。 争取每工作日做一道题。 POPIAPA，PIPOPA,  POPIPAPAPIPOPA!  其他小知识 树状数组 树状数组-利用 lowbit 的特殊数组数据结构，有奇效   前置知识 lowbit  lowbit 即一个 $n$ 的">
<meta property="og:type" content="article">
<meta property="og:title" content="算法成长日记">
<meta property="og:url" content="https://redkold.github.io/2025/07/29/algorithm-blog/index.html">
<meta property="og:site_name" content="RedKold的小站">
<meta property="og:description" content="前面的话 到大三了才深刻意识到自己算法基础的薄弱，趁暑期有时间应该多做一些算法题。 写一个c++小算法还不如大一的自己了。所以在这里分享一些。   更新了分类栏目。 争取每工作日做一道题。 POPIAPA，PIPOPA,  POPIPAPAPIPOPA!  其他小知识 树状数组 树状数组-利用 lowbit 的特殊数组数据结构，有奇效   前置知识 lowbit  lowbit 即一个 $n$ 的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kold.oss-cn-shanghai.aliyuncs.com/IMG_6759.jpeg">
<meta property="article:published_time" content="2025-07-29T01:07:13.000Z">
<meta property="article:modified_time" content="2025-11-13T11:34:43.503Z">
<meta property="article:author" content="RedKold">
<meta property="article:tag" content="止于至善">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kold.oss-cn-shanghai.aliyuncs.com/IMG_6759.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "算法成长日记",
  "url": "https://redkold.github.io/2025/07/29/algorithm-blog/",
  "image": "https://kold.oss-cn-shanghai.aliyuncs.com/IMG_6759.jpeg",
  "datePublished": "2025-07-29T01:07:13.000Z",
  "dateModified": "2025-11-13T11:34:43.503Z",
  "author": [
    {
      "@type": "Person",
      "name": "RedKold",
      "url": "https://redkold.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://redkold.github.io/2025/07/29/algorithm-blog/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法成长日记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://kold.oss-cn-shanghai.aliyuncs.com/ppp.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://kold.oss-cn-shanghai.aliyuncs.com/toyama-kasumi.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-bars"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-wheelchair-alt"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://kold.oss-cn-shanghai.aliyuncs.com/IMG_6759.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://kold.oss-cn-shanghai.aliyuncs.com/toyama-kasumi.png" alt="Logo"><span class="site-name">RedKold的小站</span></a><a class="nav-page-title" href="/"><span class="site-name">算法成长日记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-bars"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-wheelchair-alt"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">算法成长日记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-29T01:07:13.000Z" title="发表于 2025-07-29 09:07:13">2025-07-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-13T11:34:43.503Z" title="更新于 2025-11-13 19:34:43">2025-11-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="前面的话">前面的话</h2>
<p>到大三了才深刻意识到自己算法基础的薄弱，趁暑期有时间应该多做一些算法题。<br>
写一个c++小算法还不如大一的自己了。所以在这里分享一些。</p>
<div class="note update flat"></div>
<blockquote>
<p>更新了分类栏目。<br>
争取每工作日做一道题。<br>
POPIAPA，PIPOPA,  POPIPAPAPIPOPA!</p>
</blockquote>
<h2 id="其他小知识">其他小知识</h2>
<h3 id="树状数组">树状数组</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/TheWayForDream/article/details/118436732">树状数组-利用 lowbit 的特殊数组数据结构，有奇效</a></p>
<ul>
<li>
<p><strong>前置知识</strong> <code>lowbit</code></p>
<ul>
<li><code>lowbit</code> 即一个 $n$ 的数用二进制表示，其最低位的为 1 以及其后的 0 组成的数。</li>
<li>$44=(101100)<em>{(2)}$，$lowbit((101100</em>{(2)}))=(100)_{(2)}=4$</li>
<li>怎么得到呢？
<ul>
<li><strong>将这个数取反</strong>，然后+1（这其实等价于取负），再和原来的数 <strong>与</strong> 就好了。</li>
<li>可以论证，$lowbit(x)=x&amp;(-x)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>通过树状数组结构</strong>可以快速得到一个数组某个位置<em>前面的数</em> （作为一个数，它前面的数是它的子节点）<img src="https://kold.oss-cn-shanghai.aliyuncs.com/20250619180744.png" alt="image.png|400"></p>
<ul>
<li><strong>注意</strong>：$t[x]$ 保存以 $x$ 为根的子树中叶节点的值的和。$t[4]=t[2]+t[3]+a[4]=a[1]+a[2]+a[3]+a[4]$</li>
</ul>
</li>
<li>
<p><strong>观察进一步发现</strong></p>
<ul>
<li>树状数组中，节点 $x$ 的父节点为 $x+lowbit(x)$， <strong>查父操作</strong></li>
<li><strong>单点修改</strong>
<ul>
<li><code>add</code> 操作</li>
<li>我们需要维护和结构，所以某一点更新，需要不断更新其父亲的和</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span><span class="comment">//将x点的值增加k</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=lowbit(i))</span><br><span class="line">		t[i]+=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>关于另一个操作</strong>
<ul>
<li><strong>区间查询</strong>
<ul>
<li><code>ask</code> 操作</li>
<li>例如：我们需要查询前7项的区间和 <code>sum[7]</code></li>
<li>发现 <code>sum[7]=t[7]+t[6]+t[4]</code></li>
<li><strong>又发现</strong><code>7-lowbit[7]=6, 6-lowbit[6]=4</code></li>
<li>故</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ask</span><span class="params">(x)</span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=lowbit(i))&#123;</span><br><span class="line">		sum+=t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附加一个应用<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991687/article/details/105069046">冒泡排序交换次数</a></p>
<ul>
<li><strong>思路</strong>：
<ul>
<li>冒泡排序每交换一次都消除且仅消除一个逆序对</li>
<li>只需要计算逆序对</li>
<li>由于本题的数组是 $(1\dots n)$ 随机打乱，故即 $i&lt;j,a_{i}&gt;a_{j}即a_{i}&gt;j$ 是逆序对</li>
<li>如果能快速计算某 $j$ 之前的 $i$ 的大于 $a_{j}$ 的数量就好了</li>
<li>如果我们每次将一个输入的 $a_{i}$ 插入到树状数组的 $a_{i}$ 位置并<strong>令其大小为 1</strong>，（调用 $add(a_{i},1)$）更新 $t[a_{i}]$ 的值，那么如果对于一个遍历到的 $j$，只需要调用 $ask(j)$，<strong>就可以知道树状数组前 $j$ 个元素的和。</strong></li>
<li><strong>这个前缀和</strong>$sum$，表达的是满足 $i&lt;j,a_{i}&lt;a_{j}$ 的个数（$i&lt;j$ 是由于遍历过程自然得到，$a_{i}$ 小于 $a_{j}$ 是因为我们这时候 <code>ask(j)</code>，所以 $a_{i}$ 能被查到全是在 $j$ 之前，所以 $a_{i}{&lt;j}$，由于本题的数组分布是 <code>(1..n)</code>，所以自然 $a_{i}&lt;a_{j}$）</li>
<li>我们用 $j-sum$, 就得到了逆序对的个数。（不是逆序对的元素数完了，剩下的都是逆序对）</li>
<li>把这个加总到 <code>ans</code></li>
<li>继续遍历</li>
</ul>
</li>
<li>返回结果。</li>
</ul>
<h1>应试八股</h1>
<blockquote>
<p>以个人名义稍稍强调一下答题规范，因为期中批卷感觉咱们班在答题上有点吃亏，我真诚希望咱班孩子期末能多捞点分： 首先助教批卷的注意力一般是：先看你会不会，然后看你有没有规范地说明这个问题，最后是检查一些易错的边界条件判断。 所以强调几点我个人的建议：<br>
1.思路最好多写点以及规范一点。极少部分人题解写的太少，并且没有规范说明解题过程，对于没写的部分助教可能觉得你会，但是不可能假定你会而给满分。少部分人思路只写一句话或不写思路，全靠伪代码说明，这样其实就是逼着助教逐行思考代码逻辑，而写错伪代码的概率比写错思路要大很多，所以你懂的。当然在这种情况下建议你的伪代码最好规范且精简一点。<br>
2.伪代码可以精简一些：伪代码是用于在文字叙述不够清晰直观时的补充说明，规范化地交代解题思路以及关键步骤，如果思路就已经像伪代码那样严谨的情况下甚至可以不写。有些人详细到人肉python级别，其实没有必要而且不建议。<br>
主要原因如下：<br>
①太浪费时间；<br>
②助教更关注你的算法逻辑而非代码级实现；<br>
③多写多错。<br>
3.还有极少数人会把书上的算法重复实现一遍，没有必要，书上算法可以黑盒调用（比如说快速选择算法）。<br>
4.一定要把边界情况和关键细节考虑在内。有人不写伪代码，但是思路写得跟伪代码一样，把所有初始结束边界情况和实现细节考虑到了，一样是满分；有的写了一大页伪代码，没有写出来那些关键的细节怎么处理，一样会扣分。建议在书写过程中认真地考虑一下，如果不留意的话，最后很可能因为以为无关大雅的实现细节而失分。最后祝大家考试加油(<em>•̀ᴗ•́</em>)و ̑̑</p>
</blockquote>
<h1>刷题</h1>
<h2 id="二进制相关">二进制相关</h2>
<h3 id="15-三数之和">15.  三数之和</h3>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<p><strong>思路</strong>：<br>
做排序，比如 <code>nums=[-1,0,1,2,-1,-4]</code> 也就是 <code>[-4,-1,-1,0,1,2]</code><br>
三元组满足</p>
<ul>
<li>先遍历找出最小的数, 调整数组做一个哈希，比如最小的数是 <code>-4</code>，则 <code>hash[0]代表-4</code></li>
<li>通过此可以将三元组转化为二元组</li>
<li><strong>但这又提醒我了</strong>：每次定一个数是谁，可以转化为二元组和问题。很方便使用双指针。因为两数之和越大，另一个数就越小，保证了遍历的高效性。
<ul>
<li><code>i</code> 定位我们找二元组的范围，然后用双指针 <code>l</code> 和 <code>r</code> 从 <code>i+1</code> 和 <code>n-1</code> 出发，相向而行</li>
</ul>
</li>
</ul>
<p>附上代码：<br>
（用 <code>cmd+shift+v</code> 才能实现纯文本复制，解决 ob 的代码格式问题）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkZero</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushInto</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; res, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        res.<span class="built_in">push_back</span>(j);</span><br><span class="line">        res.<span class="built_in">push_back</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(); <span class="comment">// 修正：使用 size() 而不是 len()</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// 最后两个数都需要留出空间</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳过重复的 i</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> r = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l&gt;n<span class="number">-1</span>)&#123; <span class="comment">//超出了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123; </span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 跳过重复的 l 和 r</span></span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) r--;</span><br><span class="line"></span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2419-按位与最大的最长子数组"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/">2419. 按位与最大的最长子数组</a></h3>
<p>只需要注意一个事实：两个数做<strong>按位与</strong>，结果小于等于二者。<br>
所以只需要找最长的<strong>包含最大数的序列。</strong></p>
<ul>
<li><strong>有个小细节</strong>要注意一下：你要找所有子序列中最长的由最大数组成的序列</li>
<li>比如<code>55555 45555 555</code>，最长的是<code>5555555(6:12)</code></li>
</ul>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m=*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==m)&#123; <span class="comment">// 如果是以最大值开始的序列</span></span><br><span class="line">                <span class="keyword">while</span>(j&lt;len &amp;&amp; nums[j]==m)&#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已经数完了当前的序列长度</span></span><br><span class="line">            res=<span class="built_in">max</span>(res,j-i);</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="326-3-的幂"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/power-of-three/">326. 3 的幂</a></h3>
<h3 id="2438-二的幂数组中查询范围内的乘积"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-product-queries-of-powers/">2438. 二的幂数组中查询范围内的乘积</a></h3>
<h4 id="解答">解答</h4>
<p><img src="https://kold.oss-cn-shanghai.aliyuncs.com/20250811164522.png" alt="image.png"></p>
<p>这个题目，<strong>最关键的是二进制分解</strong>。<br>
<strong>如何快速知道每个数由2的多少次幂相加得到？</strong><br>
——二进制表示，某bit为1就是需要加这个bit对应的数，为0则不加。</p>
<p><strong>这里</strong>需要注意一点，根据离散数学知识，<code>mod</code>的性质：对于我们运算得到的很大的数取模，等价于对于这个数的每一个因子（也就是<code>[left,right]</code>范围内的2的某次幂的数列）取模。</p>
<p>容易得到代码</p>
<h4 id="代码">代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAns</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,vector&lt;<span class="type">int</span>&gt;&amp; powers)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            cur = <span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(cur) * powers[i] % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productQueries</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// use binary to express n</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; powers;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> tmp=n;</span><br><span class="line">        <span class="type">int</span> bitnum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp%<span class="number">2</span>)&#123;powers.<span class="built_in">push_back</span>(bitnum);&#125;</span><br><span class="line">            bitnum*=<span class="number">2</span>;</span><br><span class="line">            tmp=tmp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;queries.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> res_i=<span class="built_in">getAns</span>(queries[i][<span class="number">0</span>],queries[i][<span class="number">1</span>],powers);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res_i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分析">分析</h4>
<ol>
<li>试除法</li>
</ol>
<p>判断一个数是不是3的次幂。<br>
<strong>我们可以通过不断除这个数来看。</strong></p>
<p>注意负数和0一定不是3的次幂。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp=n;</span><br><span class="line">        <span class="keyword">while</span>(tmp&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp%<span class="number">3</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在本题INT范围内，有符号整数范围内最大的一个3的幂是<code>3^19=1,162,261,467</code></li>
</ol>
<p>所以只要检查<code>n</code>是不是其约数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3495-使数组元素都变为零的最少操作次数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-operations-to-make-array-elements-zero/">3495. 使数组元素都变为零的最少操作次数</a></h3>
<blockquote>
<p>给你一个二维数组 <code>queries</code>，其中 <code>queries[i]</code> 形式为 <code>[l, r]</code>。每个 <code>queries[i]</code> 表示了一个元素范围从 <code>l</code> 到 <code>r</code> （包括 <strong>l</strong> 和 <strong>r</strong> ）的整数数组 <code>nums</code> 。<br>
在一次操作中，你可以：</p>
<ul>
<li>选择一个查询数组中的两个整数 <code>a</code> 和 <code>b</code>。</li>
<li>将它们替换为 <code>floor(a / 4)</code> 和 <code>floor(b / 4)</code>。<br>
你的任务是确定对于每个查询，将数组中的所有元素都变为零的 <strong>最少</strong> 操作次数。返回所有查询结果的总和。</li>
</ul>
</blockquote>
<h4 id="分析-2">分析</h4>
<p>原题详细解释可以看 link<br>
这里容易看出位运算能方便做。</p>
<p>即，每个数 <code>x</code> 变为 0 的 <strong>最少操作次数</strong>，其实就是求 <code>4^(cnt-1)&lt;=x&lt;=4^cnt-1</code> cnt 的个数</p>
<p>我们可以先数出 <code>l</code> 介于什么 cnt 的范围，借助位运算来推进。</p>
<h4 id="代码-2">代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minOperations</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; query=queries[i];</span><br><span class="line">            <span class="type">int</span> l=query[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> r= query[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 0-3 need 1</span></span><br><span class="line">            <span class="comment">// 4-15 need 2</span></span><br><span class="line">            <span class="comment">// 16-4^3-1 need 3</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mybase=<span class="number">4</span>;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> cnt=<span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(mybase &lt;= l)&#123;</span><br><span class="line">               cnt++;</span><br><span class="line">               mybase&lt;&lt;=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// l need to do cnt times to get 0;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(mybase&lt;=r)&#123;</span><br><span class="line">                <span class="comment">// mybase is 4^cnt, numbers from 4^(cnt-1) to 4^cnt-1 need divide 4 for cnt times to get to 0</span></span><br><span class="line">                <span class="comment">// so it&#x27;s mybase-1 - l +1 , base -l</span></span><br><span class="line">                <span class="comment">// it&#x27;s well defined. the first l is also fit this.</span></span><br><span class="line">                sum+=(<span class="type">long</span> <span class="type">long</span>)(mybase-l)*cnt;</span><br><span class="line">                l = mybase;</span><br><span class="line">                mybase &lt;&lt;=<span class="number">2</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="comment">// cnt++;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// tail situation</span></span><br><span class="line">            <span class="comment">// now l&lt;=r&lt;mybase, we neet to count (r-l+1)*cnt</span></span><br><span class="line">            sum+=(r-l<span class="number">+1</span>)*cnt;</span><br><span class="line">            ans+=(sum<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以优化为前缀和，用一个匿名函数 <code>f</code> 来进一步简化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minOperations</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> f = [](<span class="type">long</span> <span class="type">long</span> x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> base = <span class="number">1</span>, cnt = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((base &lt;&lt; <span class="number">2</span>) - <span class="number">1</span> &lt;= x) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> len = (base &lt;&lt; <span class="number">2</span>) - base; <span class="comment">// 区间长度</span></span><br><span class="line">                sum += len * cnt;</span><br><span class="line">                base &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += (x - base + <span class="number">1</span>) * cnt;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;q : queries) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> l = q[<span class="number">0</span>], r = q[<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> total = <span class="built_in">f</span>(r) - <span class="built_in">f</span>(l - <span class="number">1</span>);</span><br><span class="line">            ans += (total + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="图问题">图问题</h2>
<h3 id="3341-到达最后一个房间的最短时间"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-i/?envType=daily-question&amp;envId=2025-07-30">3341. 到达最后一个房间的最短时间</a></h3>
<p>说来惭愧,<code>djikstra</code>都不熟练，找官方题解画虎的，大体类似。<br>
稍后可以发一下<code>dijkstra</code>的笔记。</p>
<p><img src="https://kold.oss-cn-shanghai.aliyuncs.com/20250730110632.png" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 建一个结构存每个点的状态</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">State</span>&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="type">int</span> dis; <span class="comment">// 到此点的最小距离</span></span><br><span class="line">        <span class="built_in">State</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> dis):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y),<span class="built_in">dis</span>(dis)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载运算符变成最小堆</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> State &amp;rth) <span class="type">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dis&gt;rth.dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存方向：又做</span></span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTimeToReach</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; moveTime)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inf=INT_MAX;</span><br><span class="line">        <span class="comment">// 记录n和m</span></span><br><span class="line">        <span class="type">int</span> n=moveTime.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m=moveTime[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 保存距离变量</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">d</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,inf));</span><br><span class="line">        <span class="comment">// 保存是否visit</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化起始点</span></span><br><span class="line">        d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;State&gt; pq;</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">State</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>())&#123;</span><br><span class="line">            State s=pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// if s is visited， skip it </span></span><br><span class="line">            <span class="keyword">if</span>(v[s.x][s.y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 标记visited</span></span><br><span class="line">            v[s.x][s.y]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// otherwise, visit neighbors of s. sue dirs</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="comment">// nx意味着neighbor x</span></span><br><span class="line">                <span class="type">int</span> nx=s.x+dirs[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> ny=s.y+dirs[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 越界直接取消</span></span><br><span class="line">                <span class="keyword">if</span>(nx&lt;<span class="number">0</span> || nx &gt;=n||ny&lt;<span class="number">0</span>||ny&gt;=m)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 房间打开需要一个时间，到达也需要一个时间，取最大者是我们能出发到这个房间的最小时间</span></span><br><span class="line">                <span class="type">int</span> dist=<span class="built_in">max</span>(moveTime[nx][ny],d[s.x][s.y])<span class="number">+1</span>; <span class="comment">//加上1 是到达nx,ny的时间</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(dist&lt;d[nx][ny])&#123;</span><br><span class="line">                    d[nx][ny]=dist;</span><br><span class="line">                    <span class="comment">// 更新heap</span></span><br><span class="line">                    pq.<span class="built_in">push</span>(<span class="built_in">State</span>(nx,ny,d[nx][ny]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="栈">栈</h2>
<h3 id="679-24-点游戏（计算器实现）"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/24-game/">679. 24 点游戏</a>（计算器实现）</h3>
<h4 id="分析-3">分析</h4>
<p>本题的思路</p>
<ul>
<li><strong>后缀表达式</strong>
<ul>
<li>括号是人类用中缀表达式规避歧义的方式，对于机器，更有效的方法是借助栈思想的后缀表达式。</li>
<li>机器不需要阅读括号。</li>
<li>比如<code>2*3-1</code>，中缀的话，可能是<code>2*(3-1)=4</code>或者<code>2*3-1=5</code></li>
<li>如果用后缀表达式，就可以无括号的区分了。前者是<code>31-2*</code>，后者是<code>23*1-</code></li>
</ul>
</li>
<li><strong>回溯</strong>
<ul>
<li>我们需要遍历<code>cards</code>的不同数字，并遍历所有运算符。</li>
<li>在尝试某个运算符的“世界线”后，如果不合适，我们需要回溯回来。</li>
<li>具体来说，我们每次取出两个数<code>l[i]</code>和<code>l[j]</code>作为运算，将运算结果<code>x</code>放回栈顶（这里用vector模拟栈），这相当于随机了后缀表达式的前两个数。</li>
<li><strong>回溯</strong>在这种设计下，即将 <code>x</code> 弹出栈。这样就回到了没有进行第一步运算的状态。接下来可以尝试其他运算符。</li>
</ul>
</li>
</ul>
<h4 id="代码-3">代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MULTIPLY 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUBTRACT 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIVIDE 3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> TARGET = <span class="number">24</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> EPSILON = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">myCal</span><span class="params">(vector&lt;<span class="type">double</span>&gt; &amp;l)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(l.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fabs</span>(l[<span class="number">0</span>] - TARGET) &lt; EPSILON;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举两个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;l.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把剩余的数字放到 next</span></span><br><span class="line">                vector&lt;<span class="type">double</span>&gt; next;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;l.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k!=i &amp;&amp; k!=j) next.<span class="built_in">push_back</span>(l[k]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历运算符</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> op=<span class="number">0</span>;op&lt;<span class="number">4</span>;op++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(op==ADD)&#123;</span><br><span class="line">                        next.<span class="built_in">push_back</span>(l[i] + l[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(op==SUBTRACT)&#123;</span><br><span class="line">                        next.<span class="built_in">push_back</span>(l[i] - l[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(op==MULTIPLY)&#123;</span><br><span class="line">                        next.<span class="built_in">push_back</span>(l[i] * l[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(op==DIVIDE)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">fabs</span>(l[j]) &lt; EPSILON) <span class="keyword">continue</span>; <span class="comment">// 除数为0，跳过</span></span><br><span class="line">                        next.<span class="built_in">push_back</span>(l[i] / l[j]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">myCal</span>(next)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    next.<span class="built_in">pop_back</span>();  <span class="comment">// 回溯, 换别的运算符</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judgePoint24</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cards)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : cards) l.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myCal</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="84-柱状图中最大的矩形（单调栈）"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a>（单调栈）</h3>
<h4 id="分析-4">分析</h4>
<p><img src="https://kold.oss-cn-shanghai.aliyuncs.com/20250822144512.png" alt="image.png"></p>
<ul>
<li>本题代码参考 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/266844/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/"> leetcode 题解</a></li>
</ul>
<p>遍历高 <code>h</code> 或遍历宽是两种思路，遍历 <code>h</code> 比较简单。</p>
<p>一旦确定 <code>h</code>，问题即找到这个 <code>h</code> 最靠左的下标 <code>i</code> 和最靠右的下标 <code>j</code>，使得 <code>k in [i,j]</code> 之间 <code>heights[k]</code> 不小于 <code>h </code></p>
<p><strong>用单调栈</strong>可以快速维护这个下标。</p>
<ul>
<li>
<p>单调栈中的元素是单调的，比如找最靠左的满足条件的下标，就可以从左往右遍历压栈，如果新元素小于等于栈顶元素则弹出，直到新元素大于栈顶元素。我们存这个下标。</p>
<ul>
<li><strong>这个操作相当于高效利用每一次比较</strong>。作为单调栈维护的大小关系已经足够我们确定下标，就不用每次都从左往右比所有元素了。而这样最多比较次数仅仅是出栈进栈，不超过 1 次，是 $O(n)$ （<strong>平摊分析</strong>）</li>
</ul>
</li>
<li>
<p>这样，每到一个新元素，我们都找到了其左边<strong>第一个</strong> <strong>小于</strong> 它的元素。确定它的下标以备后用，存储到 <code>left[]</code></p>
</li>
<li>
<p>同样的，我们找到 <code>heights[]</code> 中任意一个元素的右边第一个小于它的元素的下标，存储到 <code>right[]</code></p>
</li>
<li>
<p>由于面积计算的有效宽度，不包括第一个小于它的元素，所以我们的实际宽度 <code>w=(right[i]-1)- (left[i]+1) +1 = (right[i]-left[i]-1)</code></p>
</li>
<li>
<p>枚举每一个高度（这里实际是遍历了 <code>heights</code> 的元素，找到对应下标的 <code>left</code> 和 <code>right</code>），然后得到最大值。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n =heights.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n,n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 出现了第一个比左侧小的</span></span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; heights[i]&lt;=heights[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (st.<span class="built_in">empty</span>()? <span class="number">-1</span> : st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st= <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; heights[i]&lt;=heights[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (st.<span class="built_in">empty</span>()? n : st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 注意我们的下标是向左（向右）第一个不满足的下标，实际计算面积要考虑满足的 是</span></span><br><span class="line">            <span class="comment">//(right[i]-1-(left[i]+1) +1 )=right[i]-left[i]-1</span></span><br><span class="line">            res=<span class="built_in">max</span>(res, (right[i]-left[i]<span class="number">-1</span>) * heights[i] );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="排序应用">排序应用</h2>
<h3 id="3446-按对角线进行矩阵排序"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-matrix-by-diagonals/">3446. 按对角线进行矩阵排序</a></h3>
<h3 id="3027-人员站位的方案数-II"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-ii/">3027. 人员站位的方案数 II</a></h3>
<h4 id="分析-5">分析</h4>
<p>题目如下</p>
<div class="note note flat"></div>
<blockquote>
<p>给你一个  <code>n x 2</code> 的二维数组 <code>points</code> ，它表示二维平面上的一些点坐标，其中 <code>points[i] = [xi, yi]</code> 。</p>
<p>我们定义 x 轴的正方向为 <strong>右</strong> （<strong>x 轴递增的方向</strong>），x 轴的负方向为 <strong>左</strong> （<strong>x 轴递减的方向</strong>）。类似的，我们定义 y 轴的正方向为 <strong>上</strong> （<strong>y 轴递增的方向</strong>），y 轴的负方向为 <strong>下</strong> （<strong>y 轴递减的方向</strong>）。</p>
<p>你需要安排这 <code>n</code> 个人的站位，这 <code>n</code> 个人中包括 Alice 和 Bob 。你需要确保每个点处 <strong>恰好</strong> 有 <strong>一个</strong> 人。同时，Alice 想跟 Bob 单独玩耍，所以 Alice 会以 Alice 的坐标为 <strong>左上角</strong> ，Bob 的坐标为 <strong>右下角</strong> 建立一个矩形的围栏（<strong>注意</strong>，围栏可能 <strong>不</strong> 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 <strong>内部</strong> 或者 <strong>边缘</strong> 上有任何其他人，Alice 都会难过。</p>
<p>请你在确保 Alice <strong>不会</strong> 难过的前提下，返回 Alice 和 Bob 可以选择的 <strong>点对</strong> 数目。</p>
<p><strong>注意</strong>，Alice 建立的围栏必须确保 Alice 的位置是矩形的左上角，Bob 的位置是矩形的右下角。比方说，以 <code>(1, 1)</code> ，<code>(1, 3)</code> ，<code>(3, 1)</code> 和 <code>(3, 3)</code> 为矩形的四个角，给定下图的两个输入，Alice 都不能建立围栏，原因如下：</p>
<ul>
<li>图一中，Alice 在 <code>(3, 3)</code> 且 Bob 在 <code>(1, 1)</code> ，Alice 的位置不是左上角且 Bob 的位置不是右下角。</li>
<li>图二中，Alice 在 <code>(1, 3)</code> 且 Bob 在 <code>(1, 1)</code> ，Bob 的位置不是在围栏的右下角。</li>
</ul>
</blockquote>
<p><img src="https://kold.oss-cn-shanghai.aliyuncs.com/20250903114715.png" alt="image.png"></p>
<ul>
<li>Let’ s translate this condition
<ul>
<li>Assume Alice’ s position is <code>(x1,y1)</code>, and Bob’ s position is <code>(x2,y2)</code></li>
<li>Alice is at left-up Bob is at right-down, and it conclude edge and inner space situation</li>
<li>So <code>y1&gt;=y2, x1&lt;=x2</code></li>
<li>And no other points in <code>[(x1,y1) to (x2,y2)]</code>
<ul>
<li>no other points <code>m</code>, <code>x1&lt;xm&lt;x2, AND y1&lt;ym&lt;y2</code></li>
</ul>
</li>
</ul>
</li>
<li>To easily check this condition, we can pre-<strong>sort</strong>,  by <code>x</code> increasing <code>y</code> decreasing
<ul>
<li>we iterate the sorted <code>points</code>,  as <code>x1</code>
<ul>
<li>then iterate <code>x2</code> from index <code>i+1</code>, so the first condition is satisfied</li>
</ul>
</li>
<li><code>y1&gt;=y2</code>:
<ul>
<li>we use a if-condition to do this</li>
</ul>
</li>
<li><code>x1&lt;xm&lt;x2 AND y1&lt;ym&lt;y2</code>
<ul>
<li>we iterate to <code>j</code> as point <code>2</code>, we just make sure no one point <code>y1&lt;=ym&lt;=y2</code>, <code>ym&gt;y2</code> is impossible for we <code>jump off</code> <code>y2&gt;y1</code></li>
<li>so we only need to make sure  <code>ym&lt;y1</code>
<ul>
<li>we don’t need to iterate all points between <code>[i+1,j-1]</code></li>
<li>We just need to maintain <code>maxY</code> to check <code>ym&lt;y1</code> in <code>O(1)</code> time.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="代码-4">代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfPairs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(),</span><br><span class="line">                  [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>])</span><br><span class="line">                          <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; <span class="comment">// x 升序</span></span><br><span class="line">                      <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];     <span class="comment">// y 降序</span></span><br><span class="line">                  &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alice is left-up: x1&lt;=x2, y1&gt;=y2</span></span><br><span class="line">        <span class="comment">// for x is sorted increasingly, we hold x1&lt;=x2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// and no others- condition</span></span><br><span class="line">        <span class="comment">// it means points whose index in [i+1,j-1], their yx must &gt;y1 or &lt;y2, so won&#x27;t bother Alice and Bob</span></span><br><span class="line">        <span class="comment">// we maintain a max_Y as the maximum y indexd from i+1 to j-1. </span></span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> y1 = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> max_Y = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n &amp;&amp; max_Y &lt; y1; j++) &#123;</span><br><span class="line">                <span class="type">int</span> y2 = points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(y2&lt;=y1 &amp;&amp; y2&gt;max_Y)&#123;</span><br><span class="line">                    max_Y=y2;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分析-6">分析</h4>
<p><img src="https://kold.oss-cn-shanghai.aliyuncs.com/20250830135358.png" alt="image.png"></p>
<p>本题采用模拟就比较容易做<br>
模拟需要考虑</p>
<ul>
<li>怎么取出对角线的元素？</li>
<li>排序完，怎么放回去？</li>
</ul>
<p>究其根本是 <strong>如何遍历对角线的问题</strong></p>
<ul>
<li>对于左下的，可见其都从 <code>j=0</code> 开始，我们可按行遍历，且每次 <code>j</code> 增加都意味着 <code>i</code> 增加，即坐标为 <code>(i+j,j)</code>, 且满足 <code>i+j&lt;n</code>
<ul>
<li>外层循环按行，<code>i</code> 循环</li>
<li>内层从 <code>j</code> 开始</li>
</ul>
</li>
<li>右上的是对偶的。由于主对角线和左下规则一样，我们外层循环从 <code>j=1</code> 开始。</li>
</ul>
<h4 id="代码-5">代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sortMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        <span class="type">int</span> n= grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;i+j&lt;n;j++)&#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(grid[i+j][j]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;i+j&lt;n;j++)&#123;</span><br><span class="line">                grid[i+j][j]=tmp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右上角是反过来的，非递减，所以用默认less顺序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+j&lt;n;i++)&#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(grid[i][i+j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>(),<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+j&lt;n;i++)&#123;</span><br><span class="line">                grid[i][i+j]=tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="回溯">回溯</h2>
<h3 id="93-复原-IP-地址"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h3>
<p><img src="https://kold.oss-cn-shanghai.aliyuncs.com/20250804092625.png" alt="image.png"></p>
<h4 id="解析">解析</h4>
<p>这道题的最大思想就是 <strong>回溯</strong><br>
所谓回溯，就是记录你之前获得的答案，局部答案组成全局答案。</p>
<ul>
<li>为什么适用于IP地址呢？
<ul>
<li>ip地址分为4块。所以前<code>i</code>块如果确定为合法，后面类似的操作就可以了。可以按dfs的思想来做。用<code>vector&lt;int&gt; segments</code>存储每一块的数字，最后再汇总。</li>
<li>注意<code>dfs</code>中前导零处理完直接<code>return</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> SEG_CNT=<span class="number">4</span>; <span class="comment">//ip一共有四块</span></span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; segments;<span class="comment">// 存储每一个块的数字</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        string &amp;s: 目标处理的字符串</span></span><br><span class="line"><span class="comment">        int seg_start: 当前块对应的index起始位置</span></span><br><span class="line"><span class="comment">        int seg_id: 当前块对应的第几个块。一共有四块</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string &amp;s,<span class="type">int</span> seg_start,<span class="type">int</span> seg_id)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 做一些边界条件的判断</span></span><br><span class="line">        <span class="comment">// 如果遍历完了，且seg_id正好到4，就直接做。</span></span><br><span class="line">        <span class="keyword">if</span>(seg_start&gt;=s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            string ipAddr;</span><br><span class="line">            <span class="keyword">if</span>(seg_id&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SEG_CNT;++i)&#123;</span><br><span class="line">                    ipAddr+=<span class="built_in">to_string</span>(segments[i]);</span><br><span class="line">                    <span class="keyword">if</span>(i!=SEG_CNT<span class="number">-1</span>) ipAddr+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">push_back</span>((ipAddr));</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(seg_id&gt;=<span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊的：如果当前为是0，由于不能含有前导0，所以直接确定当前seg_id是0，存储并继续dfs</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">at</span>(seg_start)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            segments[seg_id]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s,seg_start<span class="number">+1</span>,seg_id<span class="number">+1</span>);</span><br><span class="line">            <span class="comment">// 当前循环结束，不需要遍历其他可能</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他情况，遍历每一种可能</span></span><br><span class="line">        <span class="type">int</span> tmp_addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> drift = <span class="number">0</span>; drift &lt;= <span class="number">3</span> &amp;&amp; seg_start + drift &lt;s.<span class="built_in">size</span>(); ++drift)&#123;</span><br><span class="line">            tmp_addr = tmp_addr * <span class="number">10</span> + (s[seg_start + drift] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmp_addr &gt; <span class="number">0xFF</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tmp_addr&gt;<span class="number">0</span> &amp;&amp; tmp_addr&lt;=<span class="number">0xFF</span>)&#123;</span><br><span class="line">                segments[seg_id] = tmp_addr;</span><br><span class="line">                <span class="built_in">dfs</span>(s, seg_start + drift<span class="number">+1</span>, seg_id + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        segments.<span class="built_in">resize</span>(SEG_CNT);</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="模拟">模拟</h2>
<p>这个类别，有一些是简单的模拟如[[#[3477. 水果成篮 II](https //leetcode. cn/problems/fruits-into-baskets-ii/description/? envType=daily-question&amp;envId=2025-08-05)|水果成篮]]，也有一些是需要数学推导后比较简单的。由于很难归类于某种套路，也相对容易，列入此列表。</p>
<hr>
<h3 id="3195-包含所有-1-的最小矩形面积-I"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-minimum-area-to-cover-all-ones-i/">3195. 包含所有 1 的最小矩形面积 I</a></h3>
<h4 id="分析-7">分析</h4>
<p>给你一个二维 <strong>二进制</strong> 数组 <code>grid</code>。请你找出一个边在水平方向和竖直方向上、面积 <strong>最小</strong> 的矩形，并且满足 <code>grid</code> 中所有的 1 都在矩形的内部。</p>
<p>返回这个矩形可能的 <strong>最小</strong> 面积。</p>
<p>这个题目很简单：要包含所有 1，其实就是找最大的矩形边界。<br>
找到 1 的坐标的左最小，右最大，上最小，下最大，就可以包含所有 1.</p>
<h4 id="代码-6">代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lm=INT_MAX,rm=<span class="number">0</span>,um=INT_MAX,dm=<span class="number">0</span>;<span class="comment">// left right up down</span></span><br><span class="line">        <span class="type">int</span> rows=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rows;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j &lt; cols; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&amp;&amp;j&lt;lm)&#123;</span><br><span class="line">                    lm=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&amp;&amp;j&gt;rm)&#123;</span><br><span class="line">                    rm=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&amp;&amp;i&lt;um)&#123;</span><br><span class="line">                    um=i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&amp;&amp;i&gt;dm)&#123;</span><br><span class="line">                    dm=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dm-um<span class="number">+1</span>)*(rm-lm<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3477-水果成篮-II"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruits-into-baskets-ii/description/?envType=daily-question&amp;envId=2025-08-05">3477. 水果成篮 II</a></h3>
<h4 id="分析-8">分析</h4>
<p>今天的只需要模拟题干意思就好了。没什么好思考的必要</p>
<h4 id="代码-7">代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numOfUnplacedFruits</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits, vector&lt;<span class="type">int</span>&gt;&amp; baskets)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isEmpty</span><span class="params">(baskets.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isPut</span><span class="params">(fruits.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fruits.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;baskets.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(baskets[j]&gt;=fruits[i] &amp;&amp; isEmpty[j])&#123;</span><br><span class="line">                    isEmpty[j]=<span class="literal">false</span>;</span><br><span class="line">                    isPut[i]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;isPut.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isPut[i]) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2348-全-0-子数组的数目"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-zero-filled-subarrays/">2348. 全 0 子数组的数目</a></h3>
<h4 id="分析-9">分析</h4>
<p>先来看看题：</p>
<blockquote></blockquote>
<pre><code>给你一个整数数组 `nums` ，返回全部为 `0` 的 **子数组** 数目。
**子数组** 是一个数组中一段连续非空元素组成的序列。
**示例 1：**
</code></pre>
<blockquote>
<p><strong>输入：</strong> <code>nums = [1,3,0,0,2,0,0,4]</code><br>
<strong>输出：</strong> 6<br>
<strong>解释：</strong><br>
子数组<code>[0]</code>出现了 4 次。<br>
子数组 <code>[0,0]</code> 出现了 2 次。<br>
不存在长度大于 <code>2</code> 的全 <code>0 </code> 子数组，所以我们返回 <code>6</code> 。</p>
</blockquote>
<p>这里的重要 insight 是认识到：子数组是<strong>连续</strong>的，每个全部为 0 的子数组的连续为 0 的最大长度一旦确定，这个局部的最大的子数组包含的符合条件的 0 子数组总数是确定的。</p>
<p>是一个简单的等差数列。</p>
<p>比如一个最大长度为 4 的，<code>0 0 0 0</code>，其中含有 4 个 <code>0</code>，3 个 <code>00</code>，2 个 <code>000</code>，1 个 <code>0000</code>，所以有 <code>(1+4)*4/2=10</code> 个。</p>
<p>算法只需要局部数出，然后分别计算等差求和即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">zeroFilledSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">long</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; size; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += (<span class="number">1</span>+j-i) * (j-i) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == size)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += (<span class="number">1</span>+j-i) * (j-i) / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="36-有效的数独"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-sudoku/">36. 有效的数独</a></h3>
<blockquote>
<p>开学了，好几天没写了，还是要坚持呢</p>
</blockquote>
<p>这次是一道数独检测题，考察哈希表的思想。——即你怎么快速确定每一位是否合乎数独规则？自然的想法是记录每一行、每一列、每一个九宫格的每种数字出现的个数。</p>
<p>如果使用 hash 表，我们可以免去复杂的遍历操作，而在 <code>O（1）</code> 时间内完成上述记录的更新和检查。<br>
故引入三个数组</p>
<ul>
<li><code>rows[9][9]</code> 其中第一个 9 代表一共 9 行的情况，第二个 9 是 hash（由于本数独数字分布 1-9 ，直接数组做 hash 也很方便）</li>
<li><code>cols[9][9]</code> 同理，记录的是列</li>
<li><code>subboxes[3][3][9]</code> 记录的是九宫格。九宫格划分直接 <code>i/3,j/3</code> 即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create a hash map. it contains 1-9 numbers appear times cnt;</span></span><br><span class="line">        <span class="type">int</span> rows[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="type">int</span> cols[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="type">int</span> subboxes[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(rows,<span class="number">0</span>,<span class="built_in">sizeof</span>(rows));</span><br><span class="line">        <span class="built_in">memset</span>(cols,<span class="number">0</span>,<span class="built_in">sizeof</span>(cols));</span><br><span class="line">        <span class="built_in">memset</span>(subboxes,<span class="number">0</span>,<span class="built_in">sizeof</span>(subboxes));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="type">char</span> c=board[i][j];</span><br><span class="line">                <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(c!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    num=c-<span class="string">&#x27;0&#x27;</span><span class="number">-1</span>;</span><br><span class="line">                    ++rows[i][num];</span><br><span class="line">                    ++cols[j][num];</span><br><span class="line">                    ++subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][num];</span><br><span class="line">                    <span class="keyword">if</span>(rows[i][num]&gt;<span class="number">1</span> </span><br><span class="line">                        || cols[j][num]&gt;<span class="number">1</span> </span><br><span class="line">                        || subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>] [num]&gt;<span class="number">1</span></span><br><span class="line">                    )<span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-Z-字形变换"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zigzag-conversion/">6. Z 字形变换</a></h3>
<h4 id="分析-10">分析</h4>
<p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。<br>
比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<p><code>string convert(string s, int numRows);</code></p>
<p>我们只要关心：每个字符在某行即可。用一个矩阵存储每一行的 <code>string</code> 是一个好方法。</p>
<h4 id="代码-8">代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows ==<span class="number">1</span> ||s.<span class="built_in">size</span>()&lt;numRows)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">rows</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="type">int</span> curRow=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> goingDown=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            rows[curRow]+=c;</span><br><span class="line">            <span class="comment">// add char at some line;</span></span><br><span class="line">            curRow+=goingDown?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// we don&#x27;t actually care about the &quot;space&quot; in a line, we only care about the char in a row</span></span><br><span class="line">            <span class="keyword">if</span>(curRow==numRows<span class="number">-1</span> || curRow==<span class="number">0</span>)&#123;</span><br><span class="line">                goingDown=!goingDown;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:rows)&#123;</span><br><span class="line">            ans+=str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="动态规划">动态规划</h2>
<h3 id="3494-酿造药水需要的最少总时间"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-minimum-amount-of-time-to-brew-potions/">3494. 酿造药水需要的最少总时间</a></h3>
<p>给你两个长度分别为 <code>n</code> 和 <code>m</code> 的整数数组 <code>skill</code> 和 <code>mana</code> 。</p>
<p>在一个实验室里，有 <code>n</code> 个巫师，他们必须按顺序酿造 <code>m</code> 个药水。每个药水的法力值为 <code>mana[j]</code>，并且每个药水 <strong>必须</strong> 依次通过 <strong>所有</strong> 巫师处理，才能完成酿造。第 <code>i</code> 个巫师在第 <code>j</code> 个药水上处理需要的时间为 <code>timeij = skill[i] * mana[j]</code>。</p>
<p>由于酿造过程非常精细，药水在当前巫师完成工作后 <strong>必须</strong> 立即传递给下一个巫师并开始处理。（<em><strong>连续性</strong></em>）这意味着时间必须保持 <strong>同步</strong>，确保每个巫师在药水到达时 <strong>马上</strong> 开始工作。</p>
<p>返回酿造所有药水所需的 <strong>最短</strong> 总时间。</p>
<h4 id="分析-11">分析</h4>
<p>本题最重要的一点，<strong>是确认每一轮酿造过程中</strong>，巫师酿造结束的 <strong>最早时间</strong></p>
<ul>
<li>酿造 <strong>什么时候开始</strong> 并不清晰，反而思考酿造的结束。</li>
<li>每一个人越早开始酿造，<strong>显然结束的越早</strong>。巫师 <code>i</code> 能开始酿造，<strong>一方面前一个人 <code>i-1</code> 酿造 <code>j</code> 药水结束</strong>，另一方面巫师 <code>i</code> 酿造完了 <code>j-1</code> 药水，从这个角度思考，每一轮的最优解 <code>times[n-1][j]</code> 是通过<strong>动态规划转移方程</strong>
<ul>
<li><code>times[i][j] = max(times[i][j-1], times[i-1][j]) + skill[i] * mana[j]</code></li>
</ul>
</li>
<li>得到的
<ul>
<li>而 <code>times[i-1][j]</code> 的最优情况其实也取决于 <code>times[n-1][j]</code> 的真正结果，我们需要反向更新来得到。<strong>但是这只影响后续计算的 <code>times[i][j-1], for larger j</code></strong>，本轮的 <code>times[n-1][j]</code> 结果是正确的。</li>
</ul>
</li>
</ul>
<p>我们用 <code>cur_time</code> 记录每一瓶药酿造结束，进入下一瓶药处理的<strong>时间刻</strong>。<code>times[i]</code> 记录每一轮迭代中，巫师 <code>i</code> 酿造结束的<strong>最早时间。</strong></p>
<ul>
<li>
<p>可能 <code>times[i] &gt; cur_time</code> 这意味着，我们需要等待。</p>
</li>
<li>
<p>否则，<code>times[i] &lt;= cur_time</code>，前一瓶药酿造完，我们可以立刻开始酿造。</p>
</li>
<li>
<p>我们最初，对 <code>times[i]</code> 实际没有估计（表现为代码里为 <code>0</code>），这实际是假设我们在这一轮可以<strong>不连续</strong>的酿造。我们在完成酿造后，根据得到的结果，优化每一瓶药的酿造时间。</p>
<ul>
<li><code>times[i] = times[i+1] - skill[i+1] * mana[j]</code></li>
</ul>
</li>
<li>
<p><strong>然后我们接着考虑下一瓶药</strong>。</p>
<ul>
<li><code>cur_time = max(cur_time, times[i]) + skill[i] * mana[j]</code>
<ul>
<li>这里的 <code>times[i]</code> 是完成第 <code>j</code> 个药所需要的时间，计算完 <code>times[n-1]</code> 之后，我们需要反向更新一下之前假设不连续导致的<strong>空隙</strong>。</li>
<li>具体而言，每一轮计算出的 <code>times[n-1][j]</code> （虽然没有 <code>[j]</code>，但是这样可以更方便表示）是准确的。但是这瓶药在经手每一个巫师时，该巫师的<strong>结束时间</strong>是一个区间。</li>
<li>我们通过 <code>times[i] = times[i+1] - skill[i+1] * mana[j]</code>，来得到结束时间的最大值，来尽量错配时间，达到 <strong>完全连续</strong> 的生产时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minTime</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; skill, vector&lt;<span class="type">int</span>&gt;&amp; mana)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = skill.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = mana.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">times</span><span class="params">(n)</span></span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="comment">// cur_time: one iteration, our cost of time</span></span><br><span class="line">            ll cur_time=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// all the people before n-1 wizzar have done.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                cur_time = <span class="built_in">max</span>(cur_time, times[i]) + skill[i] * mana[j];</span><br><span class="line">                <span class="comment">// the first potion is all the time add up.</span></span><br><span class="line">                <span class="comment">// and we can use this potion&#x27;s time to calculate the finish time time[i][j] for each wizzar i</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// times[i] at the first loop is all 0;</span></span><br><span class="line">            times[n<span class="number">-1</span>] = cur_time;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update times[]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">                times[i]=times[i<span class="number">+1</span>]-skill[i<span class="number">+1</span>]*mana[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> times[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3363-最多可收集的水果数目"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-maximum-number-of-fruits-collected/">3363. 最多可收集的水果数目</a></h3>
<p><img src="https://kold.oss-cn-shanghai.aliyuncs.com/20250807142453.png" alt="image.png"></p>
<p>考虑使用动态规划。</p>
<h4 id="分析-12">分析</h4>
<p>几个小思考：</p>
<ul>
<li>由于每一位小朋友都会 <strong>恰好</strong> 移动<code>n-1</code>次，到达房间<code>(n-1,n-1)</code>，所以第一个小朋友的路线固定为主对角线。
<ul>
<li>不需要再考虑，最优解<code>&gt;= 主对角线元素和</code></li>
<li>做完这一步，将主对角线水果数量设置为0。避免再走。
<ul>
<li>设置为0是比较合适的。因为虽然不会逾越对角线，但是一定会用到<code>fruit[n-1][n-1]</code></li>
</ul>
</li>
</ul>
</li>
<li>如果某小朋友<strong>逾越</strong>了主对角线，容易发现他无法在n-1步到达<code>(n-1,n-1)</code>
<ul>
<li>所以在最优解，其他两个小朋友分别在上三角和下三角活动</li>
</ul>
</li>
<li>考虑DP
<ul>
<li>以上三角小朋友为例</li>
<li>用<code>dp1[i,j]</code>表达上三角小朋友在<code>(i,j)</code>格子处最大水果数
<ul>
<li><code>dp[0,n-1]=fruits[0][n-1]</code></li>
<li><code>dp[i,j]=max&#123;dp[i-1,j-1],dp[i-1,j],dp[i-1,j+1]&#125;+fruit[i,j]</code>
<ul>
<li>if exists</li>
</ul>
</li>
</ul>
</li>
<li>用<code>dp2[i,j]</code>表达下三角小朋友在<code>(i,j)</code>格子处最大水果数
<ul>
<li><code>dp[n-1,0]=fruits[n-1][0]</code></li>
<li><code>dp[i,j]=max&#123;dp[i+1,j-1],dp[i,j-1],dp[i-1,j-1]&#125;+fruit[i,j]</code>
<ul>
<li>if exists</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="代码-9">代码</h4>
<p>开始写代码.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMyMax1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&gt;m)&#123;m=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];&#125;</span><br><span class="line">        <span class="keyword">if</span>(j<span class="number">+1</span>&lt;n &amp;&amp; dp[i<span class="number">-1</span>][j<span class="number">+1</span>]&gt;m)&#123;m=dp[i<span class="number">-1</span>][j<span class="number">+1</span>];&#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMyMax2</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=dp[i][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&gt;m)&#123;m=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];&#125;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">+1</span>&lt;n&amp;&amp;dp[i<span class="number">+1</span>][j<span class="number">-1</span>]&gt;m)&#123;m=dp[i<span class="number">+1</span>][j<span class="number">-1</span>];&#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCollectedFruits</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        n = fruits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主对角线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res += fruits[i][i];</span><br><span class="line">            fruits[i][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp1</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, -INF));</span><br><span class="line">        dp1[<span class="number">0</span>][n - <span class="number">1</span>] = fruits[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp2</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, -INF));</span><br><span class="line">        dp2[n - <span class="number">1</span>][<span class="number">0</span>] = fruits[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j&gt;=i; --j) &#123;</span><br><span class="line">                dp1[i][j] = <span class="built_in">getMyMax1</span>(i, j, dp1) + fruits[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span> ; i &gt;= j; --i) &#123;</span><br><span class="line">                dp2[i][j] = <span class="built_in">getMyMax2</span>(i, j, dp2) + fruits[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=dp2[n<span class="number">-1</span>][n<span class="number">-1</span>]+dp1[n<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="贪心">贪心</h2>
<h3 id="2561-重排水果"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rearranging-fruits/">2561. 重排水果</a></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minCost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; basket1, vector&lt;<span class="type">int</span>&gt;&amp; basket2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = INT_MAX;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; frequency;</span><br><span class="line">        <span class="comment">// find the minimum element in both baskets and count the frequency of each element</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x1 : basket1)</span><br><span class="line">        &#123;</span><br><span class="line">            frequency[x1]++;</span><br><span class="line">            m=<span class="built_in">min</span>(m, x1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x2 : basket2) &#123;</span><br><span class="line">           frequency[x2]--;</span><br><span class="line">           m=<span class="built_in">min</span>(m, x2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; to_be_swap; <span class="comment">// 记录需要交换的元素</span></span><br><span class="line">        <span class="comment">// 交换是什么样的？比如basket 1 成本为4的有x个，basket 2 成本为4的有y个，应该保证多的那个交换(x-y)/2个。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, c] : frequency)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// If any element has an odd frequency,then can&#x27;t divide into 2 basket, return -1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>(c/<span class="number">2</span>); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                to_be_swap.<span class="built_in">push_back</span>(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将to_be_swap中的元素排序</span></span><br><span class="line">        <span class="comment">// 我们将成本较小的元素放在前面，这样可以最小化总成本，交换前一半即可。</span></span><br><span class="line">        <span class="comment">// 需要注意每个元素交换不一定只交换一次，可以以最小元素m为跳板交换两次达到效果。需要比较2m和每个元素的成本</span></span><br><span class="line">        <span class="built_in">sort</span>(to_be_swap.<span class="built_in">begin</span>(), to_be_swap.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;to_be_swap.<span class="built_in">size</span>()/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">min</span>(to_be_swap[i], <span class="number">2</span> * m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2598-执行操作后的最大-MEX"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/">2598. 执行操作后的最大 MEX</a></h3>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>value</code> 。<br>
在一步操作中，你可以对 <code>nums</code> 中的任一元素加上或减去 <code>value</code> 。</p>
<ul>
<li>例如，如果 <code>nums = [1,2,3]</code> 且 <code>value = 2</code> ，你可以选择 <code>nums[0]</code> 减去 <code>value</code> ，得到 <code>nums = [-1,2,3]</code> 。<br>
数组的 MEX (minimum excluded) 是指其中数组中缺失的最小非负整数。</li>
<li>例如，<code>[-1,2,3]</code> 的 MEX 是 <code>0</code> ，而 <code>[1,0,3]</code> 的 MEX 是 <code>2</code> 。<br>
返回在执行上述操作 <strong>任意次</strong> 后，<code>nums</code> 的最大 MEX <em>。</em></li>
</ul>
<h4 id="分析-13">分析</h4>
<p>用同余的思想很好解决这个问题：</p>
<p>既然我们能对每一位加减 value <strong>任意次</strong>，则实际加减任意次后的数组，和最初的数组在 <code>mod value</code> 意义下都是等价的。</p>
<p>那么，这时候找缺失的最小非负整数的最大值，我们可以这样：</p>
<ul>
<li>先数出一个 <code>0 &lt;= nums[i] &lt; value</code> 的 <code>mod value</code> 意义下，不同数字的频数。可以用哈希表构建</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 建立同余组</span></span><br><span class="line">            cnt[(nums[i] % value +value) % value]++; <span class="comment">// 之所以这么做，为了让负数的模也&gt;0</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们可以从 <code>0</code> 开始遍历 <code>MEX</code><br>
如果 <code>MEX</code> 模 <code>value</code> 在 <code>cnt</code> 中找不到，就说明无论怎么加减，都会缺失 <code>MEX</code>。<br>
而如果能找到，我们将 <code>cnt[MEX % value]--</code>，以说明该数已经<strong>用过</strong>。<br>
然后，我们递增 <code>MEX</code>。最初找到的无法匹配 <code>cnt</code> 中的，就是最小的非负整数。<br>
而由于我们贪心的统计了所有数字的频数，涵盖了加减 <code>value</code> 任意次数的可能，保证之前的都已经用过，所以它是最大的 MEX。</p>
<h4 id="代码-10">代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findSmallestInteger</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于每个数可以加减value任意次，我们要找缺失的最小非负整数，可以同余分组来解决。</span></span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 建立同余组</span></span><br><span class="line">            cnt[(nums[i] % value + value) %</span><br><span class="line">                value]++; <span class="comment">// 之所以这么做，为了让负数的模也&gt;0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt[ans % value] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cnt[ans % value]--;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="哈希">哈希</h2>
<h3 id="LCR-063-单词替换"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/UhWRSj/">LCR 063. 单词替换</a></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceWords</span><span class="params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">dict</span><span class="params">(dictionary.begin(), dictionary.end())</span></span>;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(sentence)</span></span>;</span><br><span class="line">        string word, ans;</span><br><span class="line">        <span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; word) &#123;</span><br><span class="line">            string prefix;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                prefix = word.<span class="built_in">substr</span>(<span class="number">0</span>, j);</span><br><span class="line">                <span class="keyword">if</span> (dict.<span class="built_in">count</span>(prefix)) &#123;</span><br><span class="line">                    word = prefix;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!first) ans.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            ans += word;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Log-Thick">Log Thick</h2>
<p>这是一个利用<strong>特殊性质化简迭代的问题大类</strong>。</p>
<h3 id="蓝桥杯-2622-和与乘积"><a target="_blank" rel="noopener" href="https://www.dotcpp.com/oj/problem2622.html">蓝桥杯 2622 和与乘积 </a></h3>
<h4 id="题面">题面</h4>
<p>给定一个数列 <code> A = (a1, a2, · · · , an)</code>，问有多少个区间 <code>[L, R]</code> 满足区间内元素的乘积等于他们的和，即 <code>aL · aL+1 · · · aR = aL + aL+1 + · · · + aR</code>。</p>
<h5 id="输入格式">输入格式</h5>
<p>输入第一行包含一个整数 <code>n</code>，表示数列的长度。<br>
第二行包含 <code>n</code> 个整数，依次表示数列中的数 <code>a1, a2, · · · , an</code>。</p>
<h5 id="输出格式">输出格式</h5>
<p>输出仅一行，包含一个整数表示满足如上条件的区间的个数。</p>
<h4 id="思路">思路</h4>
<p>如果元素都是 <code>&gt;1</code> 的，容易知道乘法的增长速度远大于加法。</p>
<div class="note note flat"><p>解读</p>
</div>
<blockquote>
<p>可严格证明：如果 <code>[L, R]</code> 满足 <code>sum_lr &lt; product_lr</code>, 则 <code>[L, R+k], for some k</code>, 都 <code>sum_lk &lt; product_lk</code></p>
</blockquote>
<blockquote>
<p>但是本题有 <code>1</code> 元素，我们单独处理。把 <code>&gt;1</code> 的元素单挑出来。记录其下标。这样可以减少溢出</p>
</blockquote>
<div class="note question flat"><p>怎么处理 <code>1</code> 元素呢？</p>
</div>
<blockquote>
<p><code>1</code> 元素有个有趣的性质：在序列和 <code>sum_ij</code>、序列乘积 <code>product_ij</code> 中，<strong>有且仅有</strong> <code>1</code> 元素加入序列， <code>sum_ij</code> 可以单调增加 <code>1</code> 而 <code>product_ij</code> 不变。<br>
这给了一个 <code>insight</code>，我们可以计算 <code>int dis = product_ij - sum_ij</code>, 即 <code>product</code> 高于 <code>sum</code> 的部分，并提前计算好每个非 <code>1</code> 的元素，<strong>向左</strong>有多少连续的 <code>1</code> (<code>L1_Count)</code>，<strong>向右</strong>则是 <code>R1_Count</code></p>
<ul>
<li>计算连续的 <code>1</code> 的数量可以考虑用<strong>动态规划</strong>，在 <code>O(n)</code> 内完成。</li>
<li>如果左右两边的 <code>1</code> 的总数不够弥补 <code>dis</code>，则可以直接 <code>break</code>，因为此段以 <code>i</code> 开头的序列无法通过左右 <code>+1</code> 来构成答案。</li>
<li>如果可以，则利用<strong>滑动窗口</strong>确定滑动的边界。右边的 <code>1</code> 最多用 <code>r = min(rones, dis)</code> 个，左边的最多用 <code>l=min(lones, dis)</code> 个，总体来说方案数是滑动的，<code>l + r - dis +1</code> 个
<ul>
<li>代码中用的是一个更严谨的方法。通过左边用多少个 ：<code>k</code>，来构造不等式来说的。道理是一样的。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// For memset, though std::vector is preferred</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// N 应该略大于最大可能的元素数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N_MAX = <span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 数组为原始数据数组</span></span><br><span class="line"><span class="type">int</span> a[N_MAX];</span><br><span class="line"><span class="comment">// sum 数组记录前缀和数组 (使用 long long 防止溢出，尽管元素值较小)</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[N_MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 数组为 a 中值不为 1 的元素所构成的数组</span></span><br><span class="line"><span class="type">int</span> b[N_MAX];</span><br><span class="line"><span class="comment">// id[i] 表示在 b 数组中下标为 i 的元素原始下标 (在 a 数组中的下标)</span></span><br><span class="line"><span class="type">int</span> id[N_MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">// L1[i] 存储紧邻 i 左侧的连续 &#x27;1&#x27; 的数量</span></span><br><span class="line"><span class="type">int</span> L1_count[N_MAX];</span><br><span class="line"><span class="comment">// R1[i] 存储紧邻 i 右侧的连续 &#x27;1&#x27; 的数量</span></span><br><span class="line"><span class="type">int</span> R1_count[N_MAX];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> blen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 输入和预处理前缀和</span></span><br><span class="line">    <span class="keyword">if</span> (!(cin &gt;&gt; n)) <span class="keyword">return</span>;</span><br><span class="line">    ans += n; <span class="comment">// 每个单独元素 (i=j) 都是一个答案 (因为 a[i] == a[i])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 把不为 1 的元素放到 b 数组中去</span></span><br><span class="line">            b[++blen] = a[i];</span><br><span class="line">            id[blen] = i; <span class="comment">// 记录原始的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 预处理 L1_count 和 R1_count</span></span><br><span class="line">    <span class="comment">// L1_count[i]: 紧邻 a[i] 左侧连续 &#x27;1&#x27; 的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 a[i] 是 1, 它的左边连续 1 的数量是它左边那个元素的数量 + 1</span></span><br><span class="line">            L1_count[i] = L1_count[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 a[i] 不是 1, 紧邻其左侧的 1 数量为 0</span></span><br><span class="line">            L1_count[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// R1_count[i]: 紧邻 a[i] 右侧连续 &#x27;1&#x27; 的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 a[i] 是 1, 它的右边连续 1 的数量是它右边那个元素的数量 + 1</span></span><br><span class="line">            R1_count[i] = R1_count[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 a[i] 不是 1, 紧邻其右侧的 1 数量为 0</span></span><br><span class="line">            R1_count[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历由非 &#x27;1&#x27; 元素构成的子数组 B[i...j]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= blen; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> current_multi = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> idx1 = id[i]; <span class="comment">// 左起点的原始下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= blen; j++) &#123;</span><br><span class="line">            <span class="comment">// 计算 B[i...j] 的乘积</span></span><br><span class="line">            current_multi *= b[j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 剪枝: 乘积增长过快，直接大于所有元素的最大和，后续不可能再相等</span></span><br><span class="line">            <span class="keyword">if</span> (current_multi &gt; sum[n]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 跳过 i=j (单独一个元素的子数组已在 ans+=n 中计算)</span></span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> idx2 = id[j]; <span class="comment">// 右边界限点的原始下标</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算 A[idx1...idx2] 的实际和</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> current_sum = sum[idx2] - sum[idx1 - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// dis 是我们需要通过两侧 &#x27;1&#x27; 元素弥补的差值</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> dis = current_multi - current_sum;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 和大于乘积，且数组元素都 &gt;= 1，随着 j 增大，乘积会增长更快，dis 可能会变大</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算方案数</span></span><br><span class="line">            <span class="comment">// 需要 Dis 个 &#x27;1&#x27;，左侧有 X 个可用，右侧有 Y 个可用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：我们取的是 idx1 左边紧邻的 1 块，和 idx2 右边紧邻的 1 块</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> X = L1_count[idx1 - <span class="number">1</span>]; <span class="comment">// idx1 左边紧邻的 1 块数量</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> Y = R1_count[idx2 + <span class="number">1</span>]; <span class="comment">// idx2 右边紧邻的 1 块数量</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (X + Y &lt; dis) &#123;</span><br><span class="line">                <span class="comment">// 两侧 &#x27;1&#x27; 的总数不够所需差值，条件不可能成立</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有足够的 &#x27;1&#x27; 来弥补差值 Dis</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// k 是从左侧 X 个 &#x27;1&#x27; 中选取的数量</span></span><br><span class="line">                <span class="comment">// k 必须满足:</span></span><br><span class="line">                <span class="comment">// 1. 0 &lt;= k &lt;= X</span></span><br><span class="line">                <span class="comment">// 2. 0 &lt;= Dis - k &lt;= Y  =&gt; Dis - Y &lt;= k &lt;= Dis</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// k 的下限 (L_bound)</span></span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> L_bound = <span class="built_in">max</span>(<span class="number">0LL</span>, dis - Y);</span><br><span class="line">                <span class="comment">// k 的上限 (R_bound)</span></span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> R_bound = <span class="built_in">min</span>(X, dis);</span><br><span class="line">                <span class="comment">// 实际是一个滑动窗口</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 方案数 = R_bound - L_bound + 1</span></span><br><span class="line">                <span class="comment">// 必须保证 R_bound &gt;= L_bound</span></span><br><span class="line">                <span class="keyword">if</span> (R_bound &gt;= L_bound) &#123;</span><br><span class="line">                    ans += R_bound - L_bound + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提高 I/O 效率</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://redkold.github.io/">RedKold</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://redkold.github.io/2025/07/29/algorithm-blog/">https://redkold.github.io/2025/07/29/algorithm-blog/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://redkold.github.io" target="_blank">RedKold的小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%AD%A2%E4%BA%8E%E8%87%B3%E5%96%84/">止于至善</a></div><div class="post-share"><div class="social-share" data-image="https://kold.oss-cn-shanghai.aliyuncs.com/IMG_6759.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/04/%E4%BB%8EWord%E9%80%9A%E9%85%8D%E7%AC%A6%E5%88%B0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="从Word通配符到正则表达式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">从Word通配符到正则表达式</div></div><div class="info-2"><div class="info-item-1">Word 通配符 关于 Word 通配符，可以阅读这一篇文章 知乎文章-Word中查找和替换通配符用法介绍(完全版) 对于我，我是在南京证券实习过程中，用 Dify制作大模型的知识库时候，需要对 Word 格式的券商知识文件进行分块处理，希望快速查找类似于 一、 二、 这样的文本，然后替换加上分块标识符号，比如 ## 人工查找对于大文章来说比较麻烦，对于 Word 有方便的方法：使用通配符。 具体来说：  [ ] 中的内容属于指定字符查找，类似 输入“[中美]国”就可以找到“中国”、“美国”。又如： * 是匹配任意的 1 个字符 对于替换，^&amp; 是上面查找所找到的文本。相当于保留。 所以就能达到效果。 </div></div></div></a><a class="pagination-related" href="/2025/07/24/oddtaxi/" title="oddtaxi"><img class="cover" src="https://www.nme.com/wp-content/uploads/2022/01/odd-taxi-film-trailer.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">oddtaxi</div></div><div class="info-2"><div class="info-item-1">2025-2-1 看完了 Odd Taxi 这部动画，在我心目中完美呈现了动画的独特魅力。 我们为什么喜欢动画？为什么在迪士尼皮克斯能用最先进的技术摹仿瑰丽的现实世界的同时，我们仍然沉醉于 2 D 的手绘世界？因为留白与不完美，没有按照物理方程经过 01 计算得到的模拟之中，藏着无限的可能和想象。这部动画就是如此。 Odd Taxi 多方势力的角逐交织极为精彩，得益于剧本在“伏笔回收”层面已经达到了“契诃夫的军火库”级别，我在 2 天的补番中享受着自己的推理得到正反馈的快乐，以及获得新线索的无数个 “Wow Moment”，这一切都令人流连忘返。 “把所有人都看成动物”的认知障碍，少年不幸遭遇的结果，也是剧情推进的关键，除了动画，很难想象有什么手段表现这一点——毕竟，如果做成写实的电影，满大街长颈鹿和狗还说着人话的话，很奇怪不是吗？但是动画不会，所以悬念能留到最后，伴随着数个伏笔在脑子里炸开。 5 stars. </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/10/FBDP-lab1/" title="金融大数据处理技术(FBDP) lab1 日志"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-10</div><div class="info-item-2">金融大数据处理技术(FBDP) lab1 日志</div></div><div class="info-2"><div class="info-item-1">实验概况 本实验是南京大学计算机金融实验班 2023 级，金融大数据处理技术 (FBDP) 的 Hadoop 实验 1，主要是熟悉环境配置。  设备：Macbook Pro M4, ram: 24g docker + ubuntu 22.04 hadoop-3.4.2-aarch64  任务 1 环境准备 我们先用 docker 部署一个单机伪分布模式。  在终端 (我使用 iTerm2 -zsh) 输入 docker exec -it &lt;container_id&gt; /bin/bash 进入容器 sudo apt install 安装 vim 以修改设置 docker cp 命令将宿主机 Mac 下载好的 Hadoop 文件传输，解压，配置环境变量。  vi ~/.bashrc    123456789export HADOOP_HOME=/usr/local/hadoopexport HADOOP_INSTALL=$HADOOP_HOMEexport HADOOP_MAPRED_HOME=$HADOOP_HOMEexport HADOOP_COMMON_HOME=$...</div></div></div></a><a class="pagination-related" href="/2025/08/29/ICS-dairy/" title="ICS-PA日记-PA0"><img class="cover" src="https://www.manongbook.com/d/file/other/4d618006a4f9bf0b13c8a84c0de380f40.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-29</div><div class="info-item-2">ICS-PA日记-PA0</div></div><div class="info-2"><div class="info-item-1">这学期选了大名鼎鼎的 ICS，在刘杰老师班做 RISC-V 的 PA 实验。写一篇博客，来记录踩过的坑和心路历程。 PA 实验手册可参考：PA 实验手册 PA 0 主要是环境的安装和配置，我采取的方案是 MacOS 用 Windows App 连接阿里云服务器 (Ub untu 22.04) 做实验。本来以为在计算机网络课上完之后，对配置远程连接已经不在话下。但是还是遇到了一些问题。  在希望的道路上，曲曲折折的前进  运行环境搭建 1. 环境准备   云服务器：阿里云 Ubuntu 20.04   用户：kasumi（非 root，避免直接用 root 破坏环境）  之前的计网实验我都是用 root 账户做的，还沾沾自喜不用 sudo 真方便，现在看来是隐患极大的…    桌面环境：xfce 4 + xrdp  配置远程桌面 GUI，是为后面的 PA 需要一些图形化内容做准备。这个方案我的 Windows 和 Mac 都可以很方便访问阿里云的 Ubuntu，很方便我做实验和玩耍    目标：能跑 make menuconfig，配置并启动 PA 框架。    2. 安装和基本配...</div></div></div></a><a class="pagination-related" href="/2025/11/06/ics-pa2/" title="ICS-PA日记-PA2"><img class="cover" src="https://kold.oss-cn-shanghai.aliyuncs.com/IMG_9402.WEBP" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-06</div><div class="info-item-2">ICS-PA日记-PA2</div></div><div class="info-2"><div class="info-item-1">概况 本实验通过了所有 OJ 样例，实现了所有必做功能。 必答题备忘链接： 程序是个状态机-理解YEMU的执行过程 整理一条指令在 NEMU 中的执行过程 程序如何运行-理解打字小游戏如何运行 编译与链接 1 编译与链接 2 了解 Makefile 不停计算的机器 理解 YEMU 如何执行程序 理解 YEMU 如何执行程序   YEMU 可以看成是一个简化版的 NEMU, 它们的原理是相通的, 因此你需要理解 YEMU 是如何执行程序的. 具体地, 你需要  画出在 YEMU 上执行的加法程序的状态机 通过 RTFSC 理解 YEMU 如何执行一条指令  思考一下, 以上两者有什么联系?   画出在 YEMU 上执行的加法程序的状态机  在 YEMU 上执行的加法程序为： 12345678910uint8_t M[NMEM] = &#123;   // 内存, 其中包含一个计算z = x + y的程序  0b11100110,  // load  6#     | R[0] &lt;- M[y]  0b00000100,  // mov   r1, r0 | R[1] &lt;-...</div></div></div></a><a class="pagination-related" href="/2025/09/14/pa1/" title="ICS PA1 report"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">ICS PA1 report</div></div><div class="info-2"><div class="info-item-1">前言 这是 ICS PA 要求提交的实验报告。一份更具有生活化气息的通关日记待我总结一下通关全流程，修一点 bug 再来更新～ 实验进度 我完成了 PA 1 的所有内容，通过了所有测试样例，并为了调试方便，加入了逻辑与或非等运算符。 一些问题和思考 为什么 printf() 的输出要换行  事实上我经常忘记加换行，但我发现这样就会出现 &lt;some word you print balabala&gt; (nemu) ，这会使得终端页面异常丑陋，同时输出可能堆叠在一堆里，不好看。 同时，printf() 写到标准输出 stdout 并不是立刻刷新，而 \n 起到一个刷新的作用，使用换行符能及时显示，避免程序异常退出导致缓存区 log 信息没有输出。  再探表达式解析 - 分治法和栈 我在大一的 程序设计基础实验 曾经完成过一个基于 Qt 的图形化计算器，可以计算包含括号的、有小数和负数的四则运算计算器。 事实上，当时我对于 - 的多义性（二目运算符 SUB? 单目运算符 NEG ?）的处理是采用了复杂的分类讨论。由于我用栈+后缀表达式实现算术式解析 (我曾经参考的文章) ，我...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://kold.oss-cn-shanghai.aliyuncs.com/toyama-kasumi.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">RedKold</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/redkold"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/redkold" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:redkold233@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/23341766" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: ##23ade5;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为博客加入了giscus评论区系统~~来水群~~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D"><span class="toc-number">1.</span> <span class="toc-text">前面的话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">其他小知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.</span> <span class="toc-text">树状数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">应试八股</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">刷题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">二进制相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.1.</span> <span class="toc-text">15.  三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2419-%E6%8C%89%E4%BD%8D%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">2419. 按位与最大的最长子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#326-3-%E7%9A%84%E5%B9%82"><span class="toc-number">1.3.</span> <span class="toc-text">326. 3 的幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2438-%E4%BA%8C%E7%9A%84%E5%B9%82%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E8%AF%A2%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-number">1.4.</span> <span class="toc-text">2438. 二的幂数组中查询范围内的乘积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94"><span class="toc-number">1.4.1.</span> <span class="toc-text">解答</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.4.3.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3495-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E9%83%BD%E5%8F%98%E4%B8%BA%E9%9B%B6%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">3495. 使数组元素都变为零的最少操作次数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-number">1.5.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">图问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3341-%E5%88%B0%E8%BE%BE%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%88%BF%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4"><span class="toc-number">2.1.</span> <span class="toc-text">3341. 到达最后一个房间的最短时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#679-24-%E7%82%B9%E6%B8%B8%E6%88%8F%EF%BC%88%E8%AE%A1%E7%AE%97%E5%99%A8%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">679. 24 点游戏（计算器实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-3"><span class="toc-number">3.1.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">3.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%EF%BC%88%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">84. 柱状图中最大的矩形（单调栈）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-4"><span class="toc-number">3.2.1.</span> <span class="toc-text">分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">排序应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3446-%E6%8C%89%E5%AF%B9%E8%A7%92%E7%BA%BF%E8%BF%9B%E8%A1%8C%E7%9F%A9%E9%98%B5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">3446. 按对角线进行矩阵排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3027-%E4%BA%BA%E5%91%98%E7%AB%99%E4%BD%8D%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0-II"><span class="toc-number">4.2.</span> <span class="toc-text">3027. 人员站位的方案数 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-5"><span class="toc-number">4.2.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">4.2.2.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-6"><span class="toc-number">4.2.3.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">4.2.4.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">5.</span> <span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#93-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">5.1.</span> <span class="toc-text">93. 复原 IP 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">5.1.1.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F"><span class="toc-number">6.</span> <span class="toc-text">模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3195-%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%89-1-%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF-I"><span class="toc-number">6.1.</span> <span class="toc-text">3195. 包含所有 1 的最小矩形面积 I</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-7"><span class="toc-number">6.1.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">6.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3477-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE-II"><span class="toc-number">6.2.</span> <span class="toc-text">3477. 水果成篮 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-8"><span class="toc-number">6.2.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-number">6.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2348-%E5%85%A8-0-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">6.3.</span> <span class="toc-text">2348. 全 0 子数组的数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-9"><span class="toc-number">6.3.1.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC"><span class="toc-number">6.4.</span> <span class="toc-text">36. 有效的数独</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">6.5.</span> <span class="toc-text">6. Z 字形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-10"><span class="toc-number">6.5.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-number">6.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">7.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3494-%E9%85%BF%E9%80%A0%E8%8D%AF%E6%B0%B4%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E6%80%BB%E6%97%B6%E9%97%B4"><span class="toc-number">7.1.</span> <span class="toc-text">3494. 酿造药水需要的最少总时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-11"><span class="toc-number">7.1.1.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3363-%E6%9C%80%E5%A4%9A%E5%8F%AF%E6%94%B6%E9%9B%86%E7%9A%84%E6%B0%B4%E6%9E%9C%E6%95%B0%E7%9B%AE"><span class="toc-number">7.2.</span> <span class="toc-text">3363. 最多可收集的水果数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-12"><span class="toc-number">7.2.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-number">7.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">8.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2561-%E9%87%8D%E6%8E%92%E6%B0%B4%E6%9E%9C"><span class="toc-number">8.1.</span> <span class="toc-text">2561. 重排水果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2598-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7-MEX"><span class="toc-number">8.2.</span> <span class="toc-text">2598. 执行操作后的最大 MEX</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-13"><span class="toc-number">8.2.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-number">8.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">9.</span> <span class="toc-text">哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LCR-063-%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2"><span class="toc-number">9.1.</span> <span class="toc-text">LCR 063. 单词替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Log-Thick"><span class="toc-number">10.</span> <span class="toc-text">Log Thick</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%93%9D%E6%A1%A5%E6%9D%AF-2622-%E5%92%8C%E4%B8%8E%E4%B9%98%E7%A7%AF"><span class="toc-number">10.1.</span> <span class="toc-text">蓝桥杯 2622 和与乘积 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E9%9D%A2"><span class="toc-number">10.1.1.</span> <span class="toc-text">题面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">10.1.1.2.</span> <span class="toc-text">输出格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">10.1.2.</span> <span class="toc-text">思路</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/06/ics-pa2/" title="ICS-PA日记-PA2"><img src="https://kold.oss-cn-shanghai.aliyuncs.com/IMG_9402.WEBP" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ICS-PA日记-PA2"/></a><div class="content"><a class="title" href="/2025/11/06/ics-pa2/" title="ICS-PA日记-PA2">ICS-PA日记-PA2</a><time datetime="2025-11-06T05:57:49.000Z" title="发表于 2025-11-06 13:57:49">2025-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/10/FBDP-lab1/" title="金融大数据处理技术(FBDP) lab1 日志">金融大数据处理技术(FBDP) lab1 日志</a><time datetime="2025-10-10T08:54:57.000Z" title="发表于 2025-10-10 16:54:57">2025-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/pa1/" title="ICS PA1 report">ICS PA1 report</a><time datetime="2025-09-14T09:03:51.000Z" title="发表于 2025-09-14 17:03:51">2025-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/11/jp-zzm/" title="日区旅游攻略(转载)"><img src="https://kold.oss-cn-shanghai.aliyuncs.com/IMG_1934.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="日区旅游攻略(转载)"/></a><div class="content"><a class="title" href="/2025/09/11/jp-zzm/" title="日区旅游攻略(转载)">日区旅游攻略(转载)</a><time datetime="2025-09-11T03:49:39.000Z" title="发表于 2025-09-11 11:49:39">2025-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/29/ICS-dairy/" title="ICS-PA日记-PA0"><img src="https://www.manongbook.com/d/file/other/4d618006a4f9bf0b13c8a84c0de380f40.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ICS-PA日记-PA0"/></a><div class="content"><a class="title" href="/2025/08/29/ICS-dairy/" title="ICS-PA日记-PA0">ICS-PA日记-PA0</a><time datetime="2025-08-29T03:11:59.000Z" title="发表于 2025-08-29 11:11:59">2025-08-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://kold.oss-cn-shanghai.aliyuncs.com/IMG_6759.jpeg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By RedKold</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'RedKold/redkold.github.io',
      'data-repo-id': 'R_kgDOPFXMMA',
      'data-category-id': 'DIC_kwDOPFXMMM4Cvdm_',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>